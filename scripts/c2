#!/bin/bash

# curl must be installed for this script to work
if ! command -v curl >/dev/null 2>&1
then
    echo "err: it doesn't look like curl is installed"
	echo "     curl is required for this script!"
	echo -e "     please install curl: \e[94m[sudo] apt-get install curl\e[0m"
    exit 1
fi

if [ -z $1 ]
then
	echo "err: you haven't passed any arguments"
	echo "     type '$(basename $0) help', for help"
	exit 2
fi

# define temporary output directory for logs and things
out_dir=/tmp/c2-logs
mkdir -p $out_dir

# help output
function print_help {
	local base_name=$(basename $0)
	local c="\e[0m"  # clear colour
	local b="\e[94m"  # blue
	local bb="\e[1;94m"  # bold, blue
	local bfgb="\e[34;42m"  # blue foreground, green background (like ls dir/)
	echo -e "Usage: $bb$base_name$c$b COMMAND [ COMMAND | OPTIONS ] [...]$c \n"
	echo -e "$bb$base_name$c$b help$c"
	echo -e "    This is what you've just typed to get this help message :)\n"
	echo -e "$bb$base_name$c$b logs COMMAND [ COMMAND ] [ ARGS ]$c"
	echo -e "    Operations acting on the log/output dir: $bfgb$out_dir$c"
	echo -e "  $b logs clean$c"
	echo -e "    Cleans all files from output directory"
	echo -e "  $b logs [ dir | path | where | loc ]$c"
	echo -e "    Returns just the location of output directory"
	echo -e "  $b logs COMMAND [ ARGS ]$c"
	echo -e "    Executes COMMAND with ARGS in the output directory\n"
}

# just extracted the utility function used to clean directories
function clean_dir {
	target_dir=${1:?"internal-err: didn't pass arg to clean_dir, you muppet"}

	init_file_count=$(ls $target_dir | wc -l)
	if (( init_file_count == 0 ))
	then
		echo "already clean :D"
		exit 0
	fi

	echo "cleaning $target_dir..."
	rm $target_dir/*

	echo "checking for stragglers..."
	file_count=$(ls $target_dir | wc -l)

	if (( file_count > 0 ))
	then
		if (( file_count < init_file_count ))
		then
			echo "err: hmmmmmM, stragglers - some files were not removed"
		else
			echo "err: clean failed!"
		fi
		echo "     please navigate to $target_dir/ to check on the problem"
		exit 1
	fi
	echo "clean was successful!"
	exit 0
}


outfile_base=$out_dir/$(date +"%Y%m%d_%H%M%S")
outfile=$outfile_base-out.txt
logfile=$outfile_base-log.log


case $1 in
	logs)
		if [ -z $2 ]
		then
			echo "err: ok... what do you want me to do with the logs?"
			echo "     please enter a command after 'logs'"
			exit 2
		fi

		case $2 in
			clean)
				clean_dir $out_dir
			;;

			dir | directory | path | where | loc | location)
				echo $out_dir
				;;

			*)
				cd $out_dir
				exec "${@:2}"
			;;
		esac
		;;

	# provide these options, but still prefer "help"
	-h | --help | h | help)
		print_help
		exit 0
		;;

	*)
		# for any other commands, those go to the server to be handled
		outfile=$outfile_base-response.txt
		logfile=$outfile_base-curl.log

		args=$(echo "$@" | tr ' ' ',')

		# N.B. curl -d makes POST requests
		curl -o $outfile -d "cli:$args" http://localhost:8200 &> $logfile
		;;
esac


if [ ! -f $outfile ]
then
	echo "oh noes, output file not created D:"
	if [ -f $logfile ]
	then
		echo "err: command failed, printing logs"

		cat $logfile

		exit 1
	fi
	echo "err: no logfile produced"
	exit 1
fi

cat $outfile
